
using Microsoft.VisualStudio.TestPlatform.ObjectModel;
using Microsoft.VisualStudio.TestPlatform.ObjectModel.Adapter;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Trumpf.FunctionalTests.Interfaces;

namespace Trumpf.FunctionalTests.TestAdapter.Adapter;
public class TestCaseFiltering
{
    private IDiscoveryContext DiscoveryContext { get; set; }

    private IRunContext RunContext { get; set; }

    private ILogger Logger { get; set; }

    private readonly Dictionary<string, TestProperty> possibleFilters = new()
    {
#pragma warning disable CS0618 // Type or member is obsolete
        ["TestCategory"] = TestProperty.Register("testClass.TestCategory", "TestCategory", typeof(string[]), TestPropertyAttributes.Hidden | TestPropertyAttributes.Trait, typeof(TestCase)),
#pragma warning restore CS0618 // Type or member is obsolete
        ["FullyQualifiedName"] = TestCaseProperties.FullyQualifiedName,
        ["Name"] = TestCaseProperties.DisplayName
    };

    // Initialisation for TestExecutor
    public TestCaseFiltering(IRunContext runContext, ILogger logger)
    {
        RunContext = runContext;
        this.Logger = logger;
    }

    // Initialisation for TestDiscoverer
    public TestCaseFiltering(IDiscoveryContext discoveryContext, ILogger logger)
    {
        DiscoveryContext = discoveryContext;
        this.Logger = logger;
    }

    /// <summary>
    /// Generate a filter expression using as properties the keys of the above dictionary (possibleFilters)
    /// </summary>
    /// <returns>the expression used during the execution for filtering the test cases</returns>
    public ITestCaseFilterExpression GetFilterForTestExecutor()
        => RunContext.GetTestCaseFilter(possibleFilters.Keys, propertyName => GetProperty(propertyName));

    /// <summary>
    /// Generate a filter expression using as properties the keys of the above dictionary (possibleFilters). The TestDiscoverer needs however for the option --list-tests another implementation than the TestExecutor. The implementation of discoveryContext has a method GetTestCaseFilter too (available in Microsoft.TestPlatform.CrossPlatEngine.dll)
    /// </summary>
    /// <returns>the expression used during the test discovery for filtering the test cases</returns>
    public ITestCaseFilterExpression GetFilterForTestDiscoverer()
    {
        var methodGetTestCaseFilterDiscoveryContext = DiscoveryContext.GetType().GetRuntimeMethod("GetTestCaseFilter", new[] { typeof(IEnumerable<string>), typeof(Func<string, TestProperty>) });

        var filter = methodGetTestCaseFilterDiscoveryContext.Invoke(DiscoveryContext, new object[] { possibleFilters.Keys, (Func<string, TestProperty>)GetProperty }) as ITestCaseFilterExpression;

        return filter;
    }

    /// <summary>
    /// Returns the test cases which matches the filter expression.
    /// </summary>
    /// <param name="tests">the list of tests to filter</param>
    /// <param name="filter">filter expression generated by one of the above methods</param>
    /// <param name="logger">instance to log</param>
    /// <returns></returns>
    public IEnumerable<TestCase> KeepTestsThatMatchFilter(IEnumerable<TestCase> tests, ITestCaseFilterExpression filter)
    {
        var filteredTests = new List<TestCase>();

        if (filter != null)
        {
            Logger.LogInfo($"A filter expression has been specified. Expression = {filter.TestCaseFilterValue}");
        }

        foreach (var test in tests)
        {
            if (filter != null && filter.MatchTestCase(test, filterProperty => GetTestCasePropertyValue(test, filterProperty)) == false)
            {
                Logger.LogInfo($"Skip test '{test.FullyQualifiedName}' due to filter '{filter.TestCaseFilterValue}'.");
                continue;
            }

            Logger.LogInfo($"The test '{test.FullyQualifiedName}' will be taken into account.");
            filteredTests.Add(test);
        }

        return filteredTests;
    }

    /// <summary>
    /// Check in the dictionary possibleFilters if a key has the same value than the given parameter. If yes, the value associated to the key will be returned.
    /// </summary>
    /// <param name="name">Key to check in the dictionary</param>
    /// <returns>the value of the item</returns>
    private TestProperty GetProperty(string name)
    {
        possibleFilters.TryGetValue(name, out TestProperty property);

        if (property == default)
        {
            Logger.LogError($"No filter property named {possibleFilters} is among the existing filters");
        }

        return property;
    }

    private object GetTestCasePropertyValue(TestCase tc, string filterProperty)
    {
        var property = GetProperty(filterProperty);

        if (property == default)
        {
            return null;
        }

        if (tc.Properties.Contains(property) == false)
        {
            return null;
        }

        var filterPropertyValue = tc.GetPropertyValue(property);
        return filterPropertyValue;
    }
}
